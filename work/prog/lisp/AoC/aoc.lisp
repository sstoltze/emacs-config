(defun day-1-1 ()
  (let ((list (with-open-file (f "day-1-1.input")
		(do* ((n (read-line f))
		      (len (length n))
		      (i 0 (1+ i))
		      (res (list)))
		     ((= i len) (reverse res))
		  (setq res (cons (parse-integer (string (elt n i)))
				  res))))))
    (reduce #'+
	    (do ((i 0 (1+ i))
		 (len (length list))
		 (res (list))
		 (jump ;1
		  (/ (length list) 2)
		       ))
		((= i len) res)
	      (if (= (elt list i)
		     (elt list (mod (+ i jump) len)))
		  (setq res (cons (elt list i) res)))))))

(defun day-2-1 ()
  (labels ((setup () (with-open-file (f "day-2-1.input")
		      (do ((l (read-line f nil nil)
			      (read-line f nil nil))
			   (out (list)))
			  ((null l) out)
			(setq out
			      (cons
			       (loop for i = 0 then (1+ j)
				  as j = (position #\Tab l :start i)
				  collect (parse-integer (subseq l i j))
				  while j)
			       out)
			      )))))
    (let ((arr (setup)))
      (format t "Day 2.1: ~A~%"
	      (loop for row in arr
		 summing (- (apply #'max row) (apply #'min row))))
      (format t "Day 2.2: ~A~%"
	      (loop for row in arr
		 summing
		   (do ((i 0 (1+ i))
			(n 0))
		       ((= i (length row)) n)
		     (do ((j 0 (1+ j)))
			 ((= j (length row)))
		       (if (and (not (= i j))(zerop (mod (elt row i) (elt row j))))
			   (setq n (/ (elt row i) (elt row j)) )))))))))

(defun day-4 ()
  (let ((pass (with-open-file (f "day-4.input")
		(do ((l (read-line f nil nil)
			(read-line f nil nil))
		     (out (list)))
		    ((null l) out)
		  (setq out (cons
			     (loop for i = 0 then (1+ j)
				as j = (position #\Space l
						 :start i)
      				collect (remove #\Return (subseq l i j))
				while j)
			     out))))))
    (format t "Day 4-1: ~A~%" (length (remove-if
				       #'(lambda (x)
					   (not (=
						 (length x)
						 (length (remove-duplicates x
									    :test #'equalp)))))
				       pass)))
    (format t "Day 4-2: ~A~%" (length (remove-if
				       #'(lambda (x)
					   (not (=
						 (length x)
						 (length
						  (remove-duplicates
						   (mapcar
						    #'(lambda (y)
							(sort y #'char-lessp))
						    x)
						   :test #'equalp)))))
				       pass)))))

(defun day-6 ()
  (let ((blocks (with-open-file (f "day-6.input")
		  (let ((l (read-line f)))
		    (loop for i = 0 then (1+ j)
		       as j = (position #\Tab l
					:start i)
		       collect (parse-integer (remove #\Return (subseq l i j)))
		       while j)))))
    (labels ((find-max-block (b)
	       (position (apply #'max b) b))
	     (redistribute-block (i b)
	       (let ((mem (nth i b)))
		 (setf (nth i b) 0)
		 (do ((j (mod (1+ i) (length b))
			 (mod (1+ j) (length b))))
		     ((= mem 0) b)
		   (incf (nth j b))
		   (decf mem)))))
      (do ((seen (list (copy-seq blocks)) (cons (copy-seq b) seen))
	   (b (redistribute-block (find-max-block blocks)
				  blocks)
	      (redistribute-block (find-max-block b)
				  b)))
	  ((find b seen :test #'equalp)
	   (values (length seen)
		   (- (length seen) (position
				     b
				     seen :test #'equalp
				     :from-end t))
		   b))))))

(defun day-12 ()
  (let ((connections (make-hash-table)))
    (with-open-file (f "day-12.input")
      (do ((l (read-line f nil nil)
	      (read-line f nil nil)))
	  ((null l))
	(setf (gethash (parse-integer (subseq l 0 (position #\Space l)))
		       connections)
	      (loop for i = (+ (position #\> l) 2) then (+ j 2)
		 as j = (position #\, l :start i)
		 collect (parse-integer (subseq l i j))
		 while j))))
    (labels ((connected-to (key)
	       (do ((need-to-check (list key))
		    (connected-to-key (list))
		    (curr nil))
		   ((null need-to-check) connected-to-key)
		 (setq curr (pop need-to-check))
		 (when (not (find curr connected-to-key))
		   (push curr connected-to-key)
		   (setq need-to-check (append (gethash curr connections)
					       need-to-check))))))
      (values
       (length (connected-to 0))
       (do ((groups 0 (1+ groups))
	   (keys (loop for key being the hash-keys of connections
		    collecting key)
		 (set-difference keys (connected-to (pop keys)))))
	  ((null keys) groups))))))
	
	  
(defun day-9 ()
  (labels ((process-group (string &optional (position 0) (score 1))
	     (do ((i (1+ position) (1+ i))
		  (in-garbage nil)
		  (finished nil)
		  (result score)
		  (characters-in-garbage 0))
		 (finished (values result (1- i) characters-in-garbage))
	       (let ((c (char string i)))
		 (cond ((char= c #\!) (incf i))
		       ((and (not in-garbage)
			     (char= c #\<)) (setq in-garbage t))
		       ((and in-garbage
			     (char= c #\>)) (setq in-garbage nil))
		       ((and (not in-garbage)
			     (char= c #\{))
			(multiple-value-bind (s j g) (process-group string
								    i
								    (1+ score))
			  (incf result s)
			  (setq i j)
			  (incf characters-in-garbage g)))
		       ((and (not in-garbage)
			     (char= c #\})) (setq finished t))
		       (in-garbage (incf characters-in-garbage)))))))
    (let ((stream  ;"{{{}}}"))
	   (with-open-file (f "day-9.input")
	     (read-line f))))
      (process-group stream))))
    
(defun day-3 ()
  (let ((end 368078))
	; 30 ))
    (do ((n 1 (1+ n))
	 (dir 'east)
	 (x 0)
	 (y 0)
	 (missing-print t)
	 (max-ns 0)
	 (min-ns 0)
	 (max-ew 0)
	 (min-ew 0)
	 (coords (make-hash-table :test #'equalp)))
	((= n end) (values (cons x y) coords))
      (setf (gethash (cons 0 0) coords)
	    1)
      (setf (gethash (cons x y) coords)
	    (+ (or (gethash (cons (1- x) (1- y)) coords) 0)
	       (or (gethash (cons     x  (1- y)) coords) 0)
	       (or (gethash (cons (1+ x) (1- y)) coords) 0)
	       (or (gethash (cons (1- x)     y ) coords) 0)
	       (or (gethash (cons (1+ x)     y ) coords) 0)
	       (or (gethash (cons (1- x) (1+ y)) coords) 0)
	       (or (gethash (cons     x  (1+ y)) coords) 0)
	       (or (gethash (cons (1+ x) (1+ y)) coords) 0)
	       ))
      (if (and missing-print (> (gethash (cons x y) coords) end))
	  (progn (format t "(~A, ~A) - ~A~%" x y (gethash (cons x y) coords))
		 (setq missing-print nil)))
      (case dir
	(east (if (> x max-ew)
		  (setq dir 'north
			max-ew x
			y (1+ y))
		  (incf x)))
	(north (if (> y max-ns)
		  (setq dir 'west
			max-ns y
			x (1- x))
		  (incf y)))
	(west (if (< x min-ew)
		  (setq dir 'south
			min-ew x
			y (1- y))
		  (decf x)))
	(south (if (< y min-ns)
		  (setq dir 'east
			min-ns y
			x (1+ x))
		  (decf y)))))))
		  
      
(defun day-5 ()
  (let ((instructions (with-open-file (f "day-5.input")
			(do ((l (read-line f nil nil)
				(read-line f nil nil))
			     (out (list)))
			    ((null l) (reverse out))
			  (push (parse-integer l) out)))))
;    (format t "~A" instructions)
    (do ((i 0)
	 (n 0 (1+ n)))
	((or (< i 0) (>= i (length instructions))) n)
      (let ((offset (nth i instructions)))
	(if (>= offset 3)
	    (decf (nth i instructions))
	    (incf (nth i instructions)))
	(setf i (+ i
		   offset))))))

(defun day-7 ()
  (let ((tree    (make-hash-table :test #'equalp))
	(weights (make-hash-table :test #'equalp))
	(last-name nil))
    (with-open-file (f "day-7.input")
      (do ((l (read-line f nil nil)
	      (read-line f nil nil))
	   (name nil))
	  ((null l) (setf last-name name))
	(setf name (remove #\Return
			   (subseq l 0 (position #\Space l))))
	(let ((children-start (position #\> l)))
	  (if children-start
	      (setf (gethash name
			     tree)
		    (loop for i = (+ children-start 2) then (+ j 2)
		       as j = (position #\, l :start i)
		       collect (remove #\Return (subseq l i j))
		       while j)))
	  (setf (gethash name weights)
		(parse-integer (subseq l
				       (1+ (position #\( l))
				       (position #\) l)))))))
    ;tree))
    (labels ((find-parent (program)
	       (with-hash-table-iterator (iter tree)
		 (multiple-value-bind (entry-p key val) (iter)
		   (do ((found nil))
		       ((or (null entry-p) found)
			found)
		     (if (position program val :test #'equalp)
			 (setq found key))
		     (multiple-value-setq (entry-p key val) (iter))))))
	     (find-weight (program)
	       (do ((weight   (gethash program weights))
		    (children (gethash program tree)))
		   ((null children) weight)
		 (incf weight (find-weight (pop children))))))
      (do ((done nil)
	   (name last-name))
	  (done (format t "Bottom: ~A~%" name))
	(let ((parent (find-parent name)))
	  (if parent
	      (setq name parent)
	      (setq done t))))
      (loop for children being the hash-values of tree
	 using (hash-key program)
	 do
	   (let ((children-weights (mapcar #'find-weight children)))
	     (when (not (apply #'= children-weights))
	       (format t "Children of ~A unbalanced: ~A ~A~%" program children children-weights))))
      (format t "tulwp: ~A~%" (gethash "tulwp" weights)))))


(defun day-8 ()
  (let ((instructions (with-open-file (f "day-8.input")
			(do ((l (read-line f nil nil)
				(read-line f nil nil))
			     (out (list)))
			    ((null l) (reverse out))
			  (push (cons (remove #\Return
                                              (subseq l (+ (search " if " l)
                                                           4)))
                                      (subseq l 0 (search " if " l)))
                                out))))
        (registers (make-hash-table :test #'equalp))
        (max-value 0))
    (dolist (instruction instructions)
      (let ((test   (loop for i = 0 then (1+ j)
                       as j = (position #\Space (car instruction) :start i)
                       collect (subseq (car instruction) i j)
                       while j))
            (effect (loop for i = 0 then (1+ j)
                       as j = (position #\Space (cdr instruction) :start i)
                       collect (subseq (cdr instruction) i j)
                       while j)))
 ;       (format t "~A - ~A~%" test effect)
        (let ((reg (first test))
              (fn  (second test))
              (number (parse-integer (third test))))
;          (format t "~A ~A ~A~%" reg fn number)
          (if (funcall (cond
                         ((equalp fn ">") #'>)
                         ((equalp fn "<") #'<)
                         ((equalp fn ">=") #'>=)
                         ((equalp fn "<=") #'<=)
                         ((equalp fn "==") #'eql)
                         ((equalp fn "!=") #'(lambda (x y) (not (equal x y)))))
                       (gethash reg registers 0)
                       number)
              (progn
                (if (equalp (second effect) "inc")
                    (setf (gethash (first effect) registers)
                          (+ (gethash (first effect) registers 0)
                             (parse-integer (third effect))))
                    (setf (gethash (first effect) registers)
                          (- (gethash (first effect) registers 0)
                             (parse-integer (third effect)))))
                (setq max-value (max max-value (gethash (first effect) registers))))))))
    (cons (apply #'max
                 (loop for v being the hash-values of registers collecting v))
          max-value)))
              

(defun day-23 ()
  (let ((instructions (with-open-file (f "day-23.input")
			(do ((l (read-line f nil nil)
				(read-line f nil nil))
			     (out (list)))
			    ((null l) (reverse out))
			  (push
                           (loop for i = 0 then (+ j 1)
                              as j = (position #\Space l :start i)
                              collect (if
                                       (parse-integer (subseq l i j) :junk-allowed t)
                                       (parse-integer (subseq l i j) :junk-allowed t)
                                       (remove #\Return
                                               (subseq l i j)))
                              while j)
                           out))))
        (registers (make-hash-table :test #'equalp))
        (current-instruction 0)
        (number-muls 0))
    (labels ((setr (x y) (if (numberp y)
                             (setf (gethash x registers) y)
                             (setf (gethash x registers) (gethash y registers 0))))
             (sub (x y)
               (if (numberp y)
                            (decf (gethash x registers 0) y)
                            (decf (gethash x registers 0) (gethash y registers 0))))
             (mul (x y)
               (incf number-muls)
               (if (numberp y)
                            (setf (gethash x registers)
                                  (* y
                                     (if (numberp x)
                                         x
                                         (gethash x registers 0))))
                            (setf (gethash x registers)
                                  (* (gethash y registers 0)
                                     (if (numberp x)
                                         x
                                         (gethash x registers 0))))))
             (jnz (x y)
               (if (not (= (if (numberp x)
                                        x
                                        (gethash x registers 0))
                                    0))
                            (incf current-instruction
                                  (1- (if (numberp y)
                                          y
                                          (gethash y registers 0)))))))
      (setf (gethash "a" registers) 1) ; Debug off
      (do ((inst (nth current-instruction instructions)
                 (nth current-instruction instructions)))
          ((null inst) number-muls)
        (cond ((equalp (first inst) "set")
               (setr (second inst) (third inst)))
              ((equalp (first inst) "sub")
               (sub (second inst) (third inst)))
              ((equalp (first inst) "mul")
               (mul (second inst) (third inst)))
              ((equalp (first inst) "jnz")
               (jnz (second inst) (third inst))))
        (incf current-instruction))
      (values number-muls (gethash "h" registers)))))
        
           
                            
    

